using System;
using System.Text;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

namespace Sharp
{
	public class CCommand
	{
		public readonly String command;
		public readonly String[] args;

		private CCommand(String cmd, String[] args)
		{
			this.command = cmd;
			this.args = args;
		}

		public String this[int index]
		{
			get
			{
				return this.args[index];
			}
		}

		public override string ToString()
		{
			return "CCommand[" + command + "]";
		}
	}

	public delegate void ReceiveCommand(Player player, CCommand command);


	public class Command
	{
		private static Dictionary<String, ReceiveCommand> commands = new Dictionary<String, ReceiveCommand>();

		private static bool _OnClientCommand(Player player, CCommand command)
		{
			Console.WriteLine("Player {0} ({1}) just executed: {2}", player.Name, player.Index, command);

			if (commands.ContainsKey(command[0]))
			{
				commands[command[0]](player, command);
				return true;
			}

			return false;
		}

		public static void RegisterCommand(String command, ReceiveCommand callback)
		{
			commands.Add(command, callback);
		}

	}

	public enum CommandFlags
	{
		///<summary> If this is set, don't add to linked list, etc. </summary>
		UNREGISTERED = (1 << 0),
		///<summary>Hidden in released products. Flag is removed automatically if ALLOW_DEVELOPMENT_CVARS is defined.</summary>
		DEVELOPMENTONLY = (1 << 1),
		///<summary>defined by the game DLL</summary>
		GAMEDLL = (1 << 2),
		///<summary>defined by the client DLL</summary>
		CLIENTDLL = (1 << 3),
		///<summary>Hidden. Doesn't appear in find or auto complete. Like DEVELOPMENTONLY, but can't be compiled out.</summary>
		HIDDEN = (1 << 4),
		///<summary>ConVar only. It's a server cvar, but we don't send the data since it's a password, etc.  Sends 1 if it's not bland/zero, 0 otherwise as value</summary>
		PROTECTED = (1 << 5),
		///<summary>ConVar only. This cvar cannot be changed by clients connected to a multiplayer server.</summary>
		SPONLY = (1 << 6),
		///<summary>ConVar only. set to cause it to be saved to vars.rc</summary>
		ARCHIVE = (1 << 7),
		///<summary>ConVar only. notifies players when changed</summary>
		NOTIFY = (1 << 8),
		///<summary>ConVar only. changes the client's info string</summary>
		USERINFO = (1 << 9),
		///<summary>This cvar's string cannot contain unprintable characters ( e.g., used for player name etc ).</summary>
		PRINTABLEONLY = (1 << 10),
		///<summary>If this is a FCVAR_SERVER, don't log changes to the log file / console if we are creating a log</summary>
		UNLOGGED = (1 << 11),
		///<summary>never try to print that cvar</summary>
		NEVER_AS_STRING = (1 << 12),
		///<summary>
		/// It's a ConVar that's shared between the client and the server.
		/// At signon, the values of all such ConVars are sent from the server to the client (skipped for local client, of course )
		/// If a change is requested it must come from the console (i.e., no remote client changes)
		/// If a value is changed while a server is active, it's replicated to all connected clients
		///</summary>
		REPLICATED = (1 << 13),
		///<summary>Only useable in singleplayer / debug / multiplayer and sv_cheats</summary>
		CHEAT = (1 << 14),
		///<summary>causes varnameN where N == 2 through max splitscreen slots for mod to be autogenerated</summary>
		SS = (1 << 15),
		///<summary>record this cvar when starting a demo file</summary>
		DEMO = (1 << 16),
		///<summary>don't record these command in demofiles</summary>
		DONTRECORD = (1 << 17),
		///<summary>This is one of the "added" FCVAR_SS variables for the splitscreen players</summary>
		SS_ADDED = (1 << 18),
		///<summary>Cvars tagged with this are the only cvars avaliable to customers</summary>
		RELEASE = (1 << 19),
		///<summary>If this cvar changes, it forces a material reload</summary>
		RELOAD_MATERIALS = (1 << 20),
		///<summary>If this cvar changes, if forces a texture reload</summary>
		RELOAD_TEXTURES = (1 << 21),
		///<summary>cvar cannot be changed by a client that is connected to a server</summary>
		NOT_CONNECTED = (1 << 22),
		///<summary>Indicates this cvar is read from the material system thread</summary>
		MATERIAL_SYSTEM_THREAD = (1 << 23),
		///<summary>cvar written to config.cfg on the Xbox</summary>
		ARCHIVE_XBOX = (1 << 24),
		///<summary>the server is allowed to execute this command on clients via ClientCommand/NET_StringCmd/CBaseClientState::ProcessStringCmd.</summary>
		SERVER_CAN_EXECUTE = (1 << 28),
		///<summary>If this is set, then the server is not allowed to query this cvar's value (via IServerPluginHelpers::StartQueryCvarValue).</summary>
		SERVER_CANNOT_QUERY = (1 << 29),
		///<summary>IVEngineClient::ClientCmd is allowed to execute this command. </summary>
		CLIENTCMD_CAN_EXECUTE = (1 << 30),
	}



	public abstract class ConCommand : SharpObject
	{
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void CreateServer(String command, String helpText, CommandFlags flags);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void CreateClient(String command, String helpText, CommandFlags flags);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void DisposeServer();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void DisposeClient();

        public ConCommand(String command, String helpText, CommandFlags flags)
        {
            if (Sharp.SERVER)
                CreateServer(command, helpText, flags);
            else
                CreateClient(command, helpText, flags);
        }

		public ConCommand(String command, String helpText) : this(command, helpText, 0 )
		{
		}

		public abstract void OnCommand(CCommand command);

		public virtual String[] AutoCompleteSuggest(string command)
		{
			return null;
		}

        public override void Dispose()
        {
            if (Sharp.SERVER)
                DisposeServer();
            else
                DisposeClient();
        }

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern static Player GetCommandClientClient();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        private extern static Player GetCommandClientServer();

        public static Player GetCommandClient()
        {
            return Sharp.SERVER ? GetCommandClientServer() : GetCommandClientClient();
        }

	}

    public class ConVar : SharpObject
    {
        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void CreateServer(String command, String defaultValue, String helpText, CommandFlags flags);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void CreateClient(String command, String defaultValue, String helpText, CommandFlags flags);

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void DisposeServer();

        [MethodImplAttribute(MethodImplOptions.InternalCall)]
        internal extern void DisposeClient();

        public ConVar(String command, String defaultValue, String helpText, CommandFlags flags)
        {
            if (Sharp.SERVER)
                CreateServer(command, defaultValue, helpText, flags);
            else
                CreateClient(command, defaultValue, helpText, flags);
        }

        extern public String Value
        {
            [MethodImplAttribute(MethodImplOptions.InternalCall)]
            get;
            [MethodImplAttribute(MethodImplOptions.InternalCall)]
            set;
        }

        extern public int IntValue
        {
            [MethodImplAttribute(MethodImplOptions.InternalCall)]
            get;
            [MethodImplAttribute(MethodImplOptions.InternalCall)]
            set;
        }

        extern public float FloatValue
        {
            [MethodImplAttribute(MethodImplOptions.InternalCall)]
            get;
            [MethodImplAttribute(MethodImplOptions.InternalCall)]
            set;
        }

        public virtual void OnChange(String oldStrValue, float oldFlValue)
        {
        }

        public override void Dispose()
        {
            if (Sharp.SERVER)
                DisposeServer();
            else
                DisposeClient();
        }
    }

}